// ArduinoDSL.jj - JavaCC grammar that parses a small Portuguese DSL for Arduino
// Commands supported: "acender pino N", "apagar pino N", "esperar N segundos"

options {
STATIC = false;
JAVA_UNICODE_ESCAPE = true;
}


PARSER_BEGIN(ArduinoDSLParser)
import java.util.*;
import java.io.*;
import utils.ArduinoSketchEmitter; // classe utilitária que escreve o .ino (package utils)


public class ArduinoDSLParser {
    // coletar pinos de saída (LEDs) para configurar em setup() como OUTPUT
    private Set outputPins = new LinkedHashSet();
    // coletar pinos de entrada (botões) para configurar em setup() como INPUT_PULLUP
    private Set inputPins = new LinkedHashSet();
    // corpo do loop() que será preenchido pelos comandos
    private StringBuilder loopCode = new StringBuilder();
    // nível de indentação atual (para blocos aninhados)
    // indentLevel = 1 significa indentação base do loop() (2 espaços)
    private int indentLevel = 1;
    // string de indentação base (2 espaços por nível)
    private static final String INDENT = "  ";
    
    // retorna a indentação atual baseada no nível
    private String getIndent() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < indentLevel; i++) {
            sb.append(INDENT);
        }
        return sb.toString();
    }


    /**
    * Main único: recebe opcionalmente: <input.dsl> <output.ino>
    * - se nenhum argumento: lê de stdin e escreve "generated_sketch.ino"
    */
    public static void main(String[] args) throws Exception {
        InputStream in = System.in;
        String outFile = "generated_sketch.ino";


        if (args.length > 0) in = new FileInputStream(args[0]);
        if (args.length > 1) outFile = args[1];


        // Use o construtor gerado pelo JavaCC (evite declarar construtores com a mesma assinatura)
        ArduinoDSLParser parser = new ArduinoDSLParser(new java.io.InputStreamReader(in));
        parser.Program();
        parser.emitArduinoSketch(outFile);
    }


    /**
     * Delegação para a classe utilitária que escreve o arquivo .ino
     */
    private void emitArduinoSketch(String outFilename) {
        ArduinoSketchEmitter.writeSketch(outputPins, inputPins, loopCode.toString(), outFilename);
    }
}
PARSER_END(ArduinoDSLParser)

// -------------------- Tokens --------------------

TOKEN : {
    < ACENDER: ("acender") >
  | < APAGAR:  ("apagar")  >
  | < ESPERAR: ("esperar") >
  | < PINO:    ("pino")    >
  | < LED:    ("led")    >
  | < SEGUNDOS: ("segundos" | "s" | "segundo") >
  | < NUMBER: ( ["0"-"9"] ) ( ["0"-"9"] )* >
  | < SEMI: ";" >
}

TOKEN : {
    < LBRACE: "{" >
|   < RBRACE: "}" >
|   < LPAREN: "(" >
|       < RPAREN: ")" >
|   < COLON: ":" >
}

TOKEN :
{
    <BOTAO: ("botao" | "botão") >
|   <PRESSIONADO: ("pressionado" | "apertado") >
}

TOKEN : /* TOKENS DE IMPERATIVA 1 */
{
    < IF: "se" >
|   < THEN: ("entao" | "então") >
|       < ELSE: ("senao" | "senão") >
|   < FIM: "fim" >
|   < FIMSE: "fimse" >
}

SKIP : {
    " " | "\t" | "\r" | "\n"  // whitespace
}

// -------------------- Grammar productions --------------------

void Program() : {} {
    ( Command() )* <EOF>
}

void Command() : {} {
    ( AcenderCmd() | ApagarCmd() | EsperarCmd() | IfCmd() )
}

void AcenderCmd() : { Token t; } {
    <ACENDER> (<PINO> | <LED>) t = <NUMBER> [ <SEMI> ] {
        int pin = Integer.parseInt(t.image);
        outputPins.add(pin);
        loopCode.append(getIndent() + "digitalWrite("+pin+", HIGH);\n");
    }
}

void ApagarCmd() : { Token t; } {
    <APAGAR> (<PINO> | <LED>) t = <NUMBER> [ <SEMI> ] {
        int pin = Integer.parseInt(t.image);
        outputPins.add(pin);
        loopCode.append(getIndent() + "digitalWrite("+pin+", LOW);\n");
    }
}

void EsperarCmd() : { Token t; } {
    <ESPERAR> t = <NUMBER> <SEGUNDOS> [ <SEMI> ] {
        int secs = Integer.parseInt(t.image);
        // delay expects milliseconds
        loopCode.append(getIndent() + "delay(" + (secs*1000) + ");\n");
    }
}

void IfCmd() : { Token t; int savedStartIdx; int pin; } {
    <IF> <BOTAO> t = <NUMBER> <PRESSIONADO> <THEN> 
    (
        // Sintaxe com chaves: se ... entao { ... }
        <LBRACE> 
        {
            pin = Integer.parseInt(t.image);
            inputPins.add(pin);
            // adiciona o if statement com indentação atual (nível do loop)
            loopCode.append(getIndent() + "if (digitalRead(" + pin + ") == HIGH) {\n");
            // incrementa o nível de indentação para comandos dentro do bloco
            indentLevel++;
            // salva o índice onde começam os comandos do bloco
            savedStartIdx = loopCode.length();
        }
        Command() ( Command() )* 
        <RBRACE>
        {
            // extrai o corpo do if (comandos adicionados dentro do bloco)
            String ifBody = loopCode.substring(savedStartIdx);
            // remove esses comandos do loopCode principal
            loopCode.setLength(savedStartIdx);
            
            // restaura o nível de indentação antes de fechar o bloco
            indentLevel--;
            
            // adiciona o corpo do if e fecha o bloco
            loopCode.append(ifBody);
            loopCode.append(getIndent() + "}\n");
        }
    |
        // Sintaxe com dois pontos (estilo Python): se ... entao: ... fim
        <COLON>
        {
            pin = Integer.parseInt(t.image);
            inputPins.add(pin);
            // adiciona o if statement com indentação atual (nível do loop)
            loopCode.append(getIndent() + "if (digitalRead(" + pin + ") == HIGH) {\n");
            // incrementa o nível de indentação para comandos dentro do bloco
            indentLevel++;
            // salva o índice onde começam os comandos do bloco
            savedStartIdx = loopCode.length();
        }
        Command() ( Command() )* 
        ( <FIMSE> | <FIM> )
        {
            // extrai o corpo do if (comandos adicionados dentro do bloco)
            ifBody = loopCode.substring(savedStartIdx);
            // remove esses comandos do loopCode principal
            loopCode.setLength(savedStartIdx);
            
            // restaura o nível de indentação antes de fechar o bloco
            indentLevel--;
            
            // adiciona o corpo do if e fecha o bloco
            loopCode.append(ifBody);
            loopCode.append(getIndent() + "}\n");
        }
    )
}
// optional: allow comments starting with // until end of line

TOKEN : {
    < LINE_COMMENT: "//" (~["\n","\r"]) * >
}

SKIP : {
    < LINE_COMMENT >
}

/*
Uso:
1) Gere o parser com JavaCC: javacc ArduinoDSLParser.jj
2) Compile os arquivos gerados e a classe utilitária: javac -d bin utils/*.java *.java
3) Rode: java -cp bin ArduinoDSLParser exemplo.dsl generated/meu_sketch.ino


Exemplo (.dsl):
acender pino 13
esperar 2 segundos
apagar pino 13
*/